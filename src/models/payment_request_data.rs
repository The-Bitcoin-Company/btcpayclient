/*
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct PaymentRequestData {
    /// The amount of the payment request
    #[serde(rename = "amount", skip_serializing_if = "Option::is_none")]
    pub amount: Option<String>,
    /// The title of the payment request
    #[serde(rename = "title", skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// The currency of the payment request. If empty, the store's default currency code will be used.
    #[serde(
        rename = "currency",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub currency: Option<Option<String>>,
    /// The email used in invoices generated by the payment request
    #[serde(
        rename = "email",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub email: Option<Option<String>>,
    /// The description of the payment request
    #[serde(
        rename = "description",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub description: Option<Option<String>>,
    /// The expiry date of the payment request
    #[serde(
        rename = "expiryDate",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub expiry_date: Option<Option<f64>>,
    /// An optional user-defined identifier for this payment request.
    #[serde(
        rename = "referenceId",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub reference_id: Option<Option<String>>,
    /// Whether to allow users to create invoices that partially pay the payment request
    #[serde(
        rename = "allowCustomPaymentAmounts",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub allow_custom_payment_amounts: Option<Option<bool>>,
    /// Form ID to request customer data
    #[serde(
        rename = "formId",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub form_id: Option<Option<String>>,
    /// Form data response
    #[serde(
        rename = "formResponse",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub form_response: Option<Option<serde_json::Value>>,
    /// The id of the payment request
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The store identifier that the payment request belongs to
    #[serde(rename = "storeId", skip_serializing_if = "Option::is_none")]
    pub store_id: Option<String>,
    /// Represents the status of a payment request: * `Pending`: Not enough has been paid or settled. * `Completed`: Paid and fully settled. * `Expired`: Expired before full settlement. * `Processing`: Paid enough, awaiting full settlement.
    #[serde(rename = "status", skip_serializing_if = "Option::is_none")]
    pub status: Option<Status>,
    /// The creation date of the payment request
    #[serde(rename = "createdTime", skip_serializing_if = "Option::is_none")]
    pub created_time: Option<f64>,
}

impl PaymentRequestData {
    pub fn new() -> PaymentRequestData {
        PaymentRequestData {
            amount: None,
            title: None,
            currency: None,
            email: None,
            description: None,
            expiry_date: None,
            reference_id: None,
            allow_custom_payment_amounts: None,
            form_id: None,
            form_response: None,
            id: None,
            store_id: None,
            status: None,
            created_time: None,
        }
    }
}
/// Represents the status of a payment request: * `Pending`: Not enough has been paid or settled. * `Completed`: Paid and fully settled. * `Expired`: Expired before full settlement. * `Processing`: Paid enough, awaiting full settlement.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Status {
    #[serde(rename = "Pending")]
    Pending,
    #[serde(rename = "Completed")]
    Completed,
    #[serde(rename = "Processing")]
    Processing,
    #[serde(rename = "Expired")]
    Expired,
}

impl Default for Status {
    fn default() -> Status {
        Self::Pending
    }
}
