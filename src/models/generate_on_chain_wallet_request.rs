/*
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct GenerateOnChainWalletRequest {
    /// A label that will be shown in the UI
    #[serde(rename = "label", skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// A BIP39 mnemonic
    #[serde(rename = "existingMnemonic", skip_serializing_if = "Option::is_none")]
    pub existing_mnemonic: Option<String>,
    /// A passphrase for the BIP39 mnemonic seed
    #[serde(rename = "passphrase", skip_serializing_if = "Option::is_none")]
    pub passphrase: Option<String>,
    /// The account to derive from the BIP39 mnemonic seed
    #[serde(rename = "accountNumber", skip_serializing_if = "Option::is_none")]
    pub account_number: Option<f64>,
    /// Whether to store the seed inside BTCPay Server to enable some additional services. IF `false` AND `existingMnemonic` IS NOT SPECIFIED, BE SURE TO SECURELY STORE THE SEED IN THE RESPONSE!
    #[serde(rename = "savePrivateKeys", skip_serializing_if = "Option::is_none")]
    pub save_private_keys: Option<bool>,
    /// Whether to import all addresses generated via BTCPay Server into the underlying node wallet. (Private keys will also be imported if `savePrivateKeys` is set to true.
    #[serde(rename = "importKeysToRPC", skip_serializing_if = "Option::is_none")]
    pub import_keys_to_rpc: Option<bool>,
    /// If `existingMnemonic` is not set, a mnemonic is generated using the specified wordList.
    #[serde(rename = "wordList", skip_serializing_if = "Option::is_none")]
    pub word_list: Option<WordList>,
    /// If `existingMnemonic` is not set, a mnemonic is generated using the specified wordCount.
    #[serde(rename = "wordCount", skip_serializing_if = "Option::is_none")]
    pub word_count: Option<WordCount>,
    /// the type of wallet to generate
    #[serde(rename = "scriptPubKeyType", skip_serializing_if = "Option::is_none")]
    pub script_pub_key_type: Option<ScriptPubKeyType>,
}

impl GenerateOnChainWalletRequest {
    pub fn new() -> GenerateOnChainWalletRequest {
        GenerateOnChainWalletRequest {
            label: None,
            existing_mnemonic: None,
            passphrase: None,
            account_number: None,
            save_private_keys: None,
            import_keys_to_rpc: None,
            word_list: None,
            word_count: None,
            script_pub_key_type: None,
        }
    }
}
/// If `existingMnemonic` is not set, a mnemonic is generated using the specified wordList.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum WordList {
    #[serde(rename = "ChineseSimplified")]
    ChineseSimplified,
    #[serde(rename = "ChineseTraditional")]
    ChineseTraditional,
    #[serde(rename = "Czech")]
    Czech,
    #[serde(rename = "English")]
    English,
    #[serde(rename = "French")]
    French,
    #[serde(rename = "Japanese")]
    Japanese,
    #[serde(rename = "PortugueseBrazil")]
    PortugueseBrazil,
    #[serde(rename = "Spanish")]
    Spanish,
}

impl Default for WordList {
    fn default() -> WordList {
        Self::ChineseSimplified
    }
}
/// If `existingMnemonic` is not set, a mnemonic is generated using the specified wordCount.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum WordCount {
    #[serde(rename = "12")]
    Variant12,
    #[serde(rename = "15")]
    Variant15,
    #[serde(rename = "18")]
    Variant18,
    #[serde(rename = "21")]
    Variant21,
    #[serde(rename = "24")]
    Variant24,
}

impl Default for WordCount {
    fn default() -> WordCount {
        Self::Variant12
    }
}
/// the type of wallet to generate
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ScriptPubKeyType {
    #[serde(rename = "Legacy")]
    Legacy,
    #[serde(rename = "Segwit")]
    Segwit,
    #[serde(rename = "SegwitP2SH")]
    SegwitP2Sh,
    #[serde(rename = "TaprootBIP86")]
    TaprootBip86,
}

impl Default for ScriptPubKeyType {
    fn default() -> ScriptPubKeyType {
        Self::Legacy
    }
}
