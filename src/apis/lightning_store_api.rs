/*
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`store_lightning_node_api_connect_to_node`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiConnectToNodeParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
    pub connect_to_node_request: models::ConnectToNodeRequest,
}

/// struct for passing parameters to the method [`store_lightning_node_api_create_invoice`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiCreateInvoiceParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
    pub create_lightning_invoice_request: models::CreateLightningInvoiceRequest,
}

/// struct for passing parameters to the method [`store_lightning_node_api_get_balance`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiGetBalanceParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`store_lightning_node_api_get_channels`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiGetChannelsParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`store_lightning_node_api_get_deposit_address`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiGetDepositAddressParams {
    /// The store ID
    pub store_id: String,
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
}

/// struct for passing parameters to the method [`store_lightning_node_api_get_histogram`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiGetHistogramParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`store_lightning_node_api_get_info`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiGetInfoParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`store_lightning_node_api_get_invoice`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiGetInvoiceParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
    /// The id of the lightning invoice.
    pub id: String,
}

/// struct for passing parameters to the method [`store_lightning_node_api_get_invoices`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiGetInvoicesParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
    /// Limit to pending invoices only
    pub pending_only: Option<bool>,
    /// The index of an invoice that will be used as the start of the list
    pub offset_index: Option<f64>,
}

/// struct for passing parameters to the method [`store_lightning_node_api_get_payment`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiGetPaymentParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
    /// The payment hash of the lightning payment.
    pub payment_hash: String,
}

/// struct for passing parameters to the method [`store_lightning_node_api_get_payments`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiGetPaymentsParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
    /// Also include pending payments
    pub include_pending: Option<bool>,
    /// The index of an invoice that will be used as the start of the list
    pub offset_index: Option<f64>,
}

/// struct for passing parameters to the method [`store_lightning_node_api_open_channel`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiOpenChannelParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
    pub open_lightning_channel_request: models::OpenLightningChannelRequest,
}

/// struct for passing parameters to the method [`store_lightning_node_api_pay_invoice`]
#[derive(Clone, Debug)]
pub struct StoreLightningNodeApiPayInvoiceParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The store ID
    pub store_id: String,
    pub pay_lightning_invoice_request: models::PayLightningInvoiceRequest,
}

/// struct for typed errors of method [`store_lightning_node_api_connect_to_node`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiConnectToNodeError {
    Status422(Vec<models::ValidationProblemDetailsInner>),
    Status400(models::ProblemDetails),
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_create_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiCreateInvoiceError {
    Status400(models::ProblemDetails),
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_get_balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiGetBalanceError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_get_channels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiGetChannelsError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_get_deposit_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiGetDepositAddressError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_get_histogram`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiGetHistogramError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_get_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiGetInfoError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_get_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiGetInvoiceError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_get_invoices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiGetInvoicesError {
    Status401(models::ProblemDetails),
    Status503(),
    DefaultResponse(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_get_payment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiGetPaymentError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_get_payments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiGetPaymentsError {
    Status401(models::ProblemDetails),
    Status503(),
    DefaultResponse(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_open_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiOpenChannelError {
    Status422(Vec<models::ValidationProblemDetailsInner>),
    Status400(models::ProblemDetails),
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_lightning_node_api_pay_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreLightningNodeApiPayInvoiceError {
    Status422(Vec<models::ValidationProblemDetailsInner>),
    Status400(models::ProblemDetails),
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Connect to another lightning node.
pub async fn store_lightning_node_api_connect_to_node(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiConnectToNodeParams,
) -> Result<(), Error<StoreLightningNodeApiConnectToNodeError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/connect",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.connect_to_node_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiConnectToNodeError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a lightning invoice.
pub async fn store_lightning_node_api_create_invoice(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiCreateInvoiceParams,
) -> Result<models::LightningInvoiceData, Error<StoreLightningNodeApiCreateInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.create_lightning_invoice_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningInvoiceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningInvoiceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiCreateInvoiceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View balance of the lightning node
pub async fn store_lightning_node_api_get_balance(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiGetBalanceParams,
) -> Result<models::LightningNodeBalanceData, Error<StoreLightningNodeApiGetBalanceError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/balance",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningNodeBalanceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningNodeBalanceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiGetBalanceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the current channels of the lightning node
pub async fn store_lightning_node_api_get_channels(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiGetChannelsParams,
) -> Result<Vec<models::LightningChannelData>, Error<StoreLightningNodeApiGetChannelsError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/channels",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LightningChannelData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LightningChannelData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiGetChannelsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get an on-chain deposit address for the lightning node
pub async fn store_lightning_node_api_get_deposit_address(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiGetDepositAddressParams,
) -> Result<String, Error<StoreLightningNodeApiGetDepositAddressError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/address",
        configuration.base_path,
        storeId = crate::apis::urlencode(params.store_id),
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiGetDepositAddressError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View balance histogram of the lightning node
pub async fn store_lightning_node_api_get_histogram(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiGetHistogramParams,
) -> Result<models::HistogramData, Error<StoreLightningNodeApiGetHistogramError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/histogram",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::HistogramData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::HistogramData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiGetHistogramError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the lightning node
pub async fn store_lightning_node_api_get_info(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiGetInfoParams,
) -> Result<models::LightningNodeInformationData, Error<StoreLightningNodeApiGetInfoError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/info",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningNodeInformationData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningNodeInformationData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiGetInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the requested lightning invoice
pub async fn store_lightning_node_api_get_invoice(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiGetInvoiceParams,
) -> Result<models::LightningInvoiceData, Error<StoreLightningNodeApiGetInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices/{id}",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id),
        id = crate::apis::urlencode(params.id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningInvoiceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningInvoiceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiGetInvoiceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the lightning invoices
pub async fn store_lightning_node_api_get_invoices(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiGetInvoicesParams,
) -> Result<Vec<models::LightningInvoiceData>, Error<StoreLightningNodeApiGetInvoicesError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.pending_only {
        req_builder = req_builder.query(&[("pendingOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.offset_index {
        req_builder = req_builder.query(&[("offsetIndex", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LightningInvoiceData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LightningInvoiceData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiGetInvoicesError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the requested lightning payment
pub async fn store_lightning_node_api_get_payment(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiGetPaymentParams,
) -> Result<models::LightningPaymentData, Error<StoreLightningNodeApiGetPaymentError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/payments/{paymentHash}",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id),
        paymentHash = crate::apis::urlencode(params.payment_hash)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningPaymentData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningPaymentData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiGetPaymentError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the lightning payments
pub async fn store_lightning_node_api_get_payments(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiGetPaymentsParams,
) -> Result<Vec<models::LightningPaymentData>, Error<StoreLightningNodeApiGetPaymentsError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/payments",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.include_pending {
        req_builder = req_builder.query(&[("includePending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.offset_index {
        req_builder = req_builder.query(&[("offsetIndex", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LightningPaymentData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LightningPaymentData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiGetPaymentsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Open a channel with another lightning node. You should connect to that node first.
pub async fn store_lightning_node_api_open_channel(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiOpenChannelParams,
) -> Result<(), Error<StoreLightningNodeApiOpenChannelError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/channels",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.open_lightning_channel_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiOpenChannelError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/StoreLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds — it might take longer if multiple routes are tried or a hold invoice is getting paid.
pub async fn store_lightning_node_api_pay_invoice(
    configuration: &configuration::Configuration,
    params: StoreLightningNodeApiPayInvoiceParams,
) -> Result<models::LightningPaymentData, Error<StoreLightningNodeApiPayInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices/pay",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.pay_lightning_invoice_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningPaymentData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningPaymentData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreLightningNodeApiPayInvoiceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
