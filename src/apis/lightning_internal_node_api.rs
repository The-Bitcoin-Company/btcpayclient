/*
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`internal_lightning_node_api_connect_to_node`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiConnectToNodeParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    pub connect_to_node_request: models::ConnectToNodeRequest,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_create_invoice`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiCreateInvoiceParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    pub create_lightning_invoice_request: models::CreateLightningInvoiceRequest,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_get_balance`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiGetBalanceParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_get_channels`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiGetChannelsParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_get_deposit_address`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiGetDepositAddressParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_get_histogram`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiGetHistogramParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_get_info`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiGetInfoParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_get_invoice`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiGetInvoiceParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The id of the lightning invoice.
    pub id: String,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_get_invoices`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiGetInvoicesParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// Limit to pending invoices only
    pub pending_only: Option<bool>,
    /// The index of an invoice that will be used as the start of the list
    pub offset_index: Option<f64>,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_get_payment`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiGetPaymentParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// The payment hash of the lightning payment.
    pub payment_hash: String,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_get_payments`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiGetPaymentsParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    /// Also include pending payments
    pub include_pending: Option<bool>,
    /// The index of a payment that will be used as the start of the list
    pub offset_index: Option<f64>,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_open_channel`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiOpenChannelParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    pub open_lightning_channel_request: models::OpenLightningChannelRequest,
}

/// struct for passing parameters to the method [`internal_lightning_node_api_pay_invoice`]
#[derive(Clone, Debug)]
pub struct InternalLightningNodeApiPayInvoiceParams {
    /// The cryptoCode of the lightning-node to query
    pub crypto_code: String,
    pub pay_lightning_invoice_request: models::PayLightningInvoiceRequest,
}

/// struct for typed errors of method [`internal_lightning_node_api_connect_to_node`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiConnectToNodeError {
    Status422(Vec<models::ValidationProblemDetailsInner>),
    Status400(models::ProblemDetails),
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_create_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiCreateInvoiceError {
    Status400(models::ProblemDetails),
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_get_balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiGetBalanceError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_get_channels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiGetChannelsError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_get_deposit_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiGetDepositAddressError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_get_histogram`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiGetHistogramError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_get_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiGetInfoError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_get_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiGetInvoiceError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_get_invoices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiGetInvoicesError {
    Status401(models::ProblemDetails),
    Status503(),
    DefaultResponse(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_get_payment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiGetPaymentError {
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_get_payments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiGetPaymentsError {
    Status401(models::ProblemDetails),
    Status503(),
    DefaultResponse(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_open_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiOpenChannelError {
    Status422(Vec<models::ValidationProblemDetailsInner>),
    Status400(models::ProblemDetails),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`internal_lightning_node_api_pay_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InternalLightningNodeApiPayInvoiceError {
    Status422(Vec<models::ValidationProblemDetailsInner>),
    Status400(models::ProblemDetails),
    Status503(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Connect to another lightning node.
pub async fn internal_lightning_node_api_connect_to_node(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiConnectToNodeParams,
) -> Result<(), Error<InternalLightningNodeApiConnectToNodeError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/connect",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.connect_to_node_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiConnectToNodeError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a lightning invoice.
pub async fn internal_lightning_node_api_create_invoice(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiCreateInvoiceParams,
) -> Result<models::LightningInvoiceData, Error<InternalLightningNodeApiCreateInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/invoices",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.create_lightning_invoice_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningInvoiceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningInvoiceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiCreateInvoiceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View balance of the lightning node
pub async fn internal_lightning_node_api_get_balance(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiGetBalanceParams,
) -> Result<models::LightningNodeBalanceData, Error<InternalLightningNodeApiGetBalanceError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/balance",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningNodeBalanceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningNodeBalanceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiGetBalanceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the current channels of the lightning node
pub async fn internal_lightning_node_api_get_channels(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiGetChannelsParams,
) -> Result<Vec<models::LightningChannelData>, Error<InternalLightningNodeApiGetChannelsError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/channels",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LightningChannelData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LightningChannelData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiGetChannelsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get an on-chain deposit address for the lightning node
pub async fn internal_lightning_node_api_get_deposit_address(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiGetDepositAddressParams,
) -> Result<String, Error<InternalLightningNodeApiGetDepositAddressError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/address",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiGetDepositAddressError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View balance histogram of the lightning node
pub async fn internal_lightning_node_api_get_histogram(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiGetHistogramParams,
) -> Result<models::HistogramData, Error<InternalLightningNodeApiGetHistogramError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/histogram",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::HistogramData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::HistogramData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiGetHistogramError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the lightning node
pub async fn internal_lightning_node_api_get_info(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiGetInfoParams,
) -> Result<models::LightningNodeInformationData, Error<InternalLightningNodeApiGetInfoError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/info",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningNodeInformationData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningNodeInformationData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiGetInfoError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the requested lightning invoice
pub async fn internal_lightning_node_api_get_invoice(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiGetInvoiceParams,
) -> Result<models::LightningInvoiceData, Error<InternalLightningNodeApiGetInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/invoices/{id}",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        id = crate::apis::urlencode(params.id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningInvoiceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningInvoiceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiGetInvoiceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the lightning invoices
pub async fn internal_lightning_node_api_get_invoices(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiGetInvoicesParams,
) -> Result<Vec<models::LightningInvoiceData>, Error<InternalLightningNodeApiGetInvoicesError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/invoices",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.pending_only {
        req_builder = req_builder.query(&[("pendingOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.offset_index {
        req_builder = req_builder.query(&[("offsetIndex", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LightningInvoiceData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LightningInvoiceData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiGetInvoicesError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the requested lightning payment
pub async fn internal_lightning_node_api_get_payment(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiGetPaymentParams,
) -> Result<models::LightningPaymentData, Error<InternalLightningNodeApiGetPaymentError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/payments/{paymentHash}",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code),
        paymentHash = crate::apis::urlencode(params.payment_hash)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningPaymentData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningPaymentData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiGetPaymentError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the lightning payments
pub async fn internal_lightning_node_api_get_payments(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiGetPaymentsParams,
) -> Result<Vec<models::LightningPaymentData>, Error<InternalLightningNodeApiGetPaymentsError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/payments",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.include_pending {
        req_builder = req_builder.query(&[("includePending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.offset_index {
        req_builder = req_builder.query(&[("offsetIndex", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LightningPaymentData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LightningPaymentData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiGetPaymentsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Open a channel with another lightning node. You should connect to that node first.
pub async fn internal_lightning_node_api_open_channel(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiOpenChannelParams,
) -> Result<(), Error<InternalLightningNodeApiOpenChannelError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/channels",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.open_lightning_channel_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiOpenChannelError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/InternalLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds â€” it might take longer if multiple routes are tried or a hold invoice is getting paid.
pub async fn internal_lightning_node_api_pay_invoice(
    configuration: &configuration::Configuration,
    params: InternalLightningNodeApiPayInvoiceParams,
) -> Result<models::LightningPaymentData, Error<InternalLightningNodeApiPayInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/server/lightning/{cryptoCode}/invoices/pay",
        configuration.base_path,
        cryptoCode = crate::apis::urlencode(params.crypto_code)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.pay_lightning_invoice_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LightningPaymentData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LightningPaymentData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InternalLightningNodeApiPayInvoiceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
