/*
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`pull_payments_create_payout`]
#[derive(Clone, Debug)]
pub struct PullPaymentsCreatePayoutParams {
    /// The ID of the pull payment
    pub pull_payment_id: String,
    pub create_payout_request: models::CreatePayoutRequest,
}

/// struct for passing parameters to the method [`pull_payments_get_payout`]
#[derive(Clone, Debug)]
pub struct PullPaymentsGetPayoutParams {
    /// The ID of the pull payment
    pub pull_payment_id: String,
    /// The ID of the pull payment payout
    pub payout_id: String,
}

/// struct for passing parameters to the method [`pull_payments_get_payouts`]
#[derive(Clone, Debug)]
pub struct PullPaymentsGetPayoutsParams {
    /// The ID of the pull payment
    pub pull_payment_id: String,
    /// Whether this should list cancelled payouts
    pub include_cancelled: Option<bool>,
}

/// struct for passing parameters to the method [`pull_payments_get_pull_payment`]
#[derive(Clone, Debug)]
pub struct PullPaymentsGetPullPaymentParams {
    /// The ID of the pull payment
    pub pull_payment_id: String,
}

/// struct for passing parameters to the method [`pull_payments_get_pull_payment_lnurl`]
#[derive(Clone, Debug)]
pub struct PullPaymentsGetPullPaymentLnurlParams {
    /// The ID of the pull payment
    pub pull_payment_id: String,
}

/// struct for passing parameters to the method [`pull_payments_link_boltcard`]
#[derive(Clone, Debug)]
pub struct PullPaymentsLinkBoltcardParams {
    /// The ID of the pull payment
    pub pull_payment_id: String,
    pub pull_payments_link_boltcard_request: Option<models::PullPaymentsLinkBoltcardRequest>,
}

/// struct for typed errors of method [`pull_payments_create_payout`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PullPaymentsCreatePayoutError {
    Status404(),
    Status422(Vec<models::ValidationProblemDetailsInner>),
    Status400(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pull_payments_get_payout`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PullPaymentsGetPayoutError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pull_payments_get_payouts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PullPaymentsGetPayoutsError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pull_payments_get_pull_payment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PullPaymentsGetPullPaymentError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pull_payments_get_pull_payment_lnurl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PullPaymentsGetPullPaymentLnurlError {
    Status404(),
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pull_payments_link_boltcard`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PullPaymentsLinkBoltcardError {
    Status404(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// Create a new payout
pub async fn pull_payments_create_payout(
    configuration: &configuration::Configuration,
    params: PullPaymentsCreatePayoutParams,
) -> Result<models::PayoutData, Error<PullPaymentsCreatePayoutError>> {
    let uri_str = format!(
        "{}/api/v1/pull-payments/{pullPaymentId}/payouts",
        configuration.base_path,
        pullPaymentId = crate::apis::urlencode(params.pull_payment_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.create_payout_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PayoutData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PayoutData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PullPaymentsCreatePayoutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get payout
pub async fn pull_payments_get_payout(
    configuration: &configuration::Configuration,
    params: PullPaymentsGetPayoutParams,
) -> Result<models::PayoutData, Error<PullPaymentsGetPayoutError>> {
    let uri_str = format!(
        "{}/api/v1/pull-payments/{pullPaymentId}/payouts/{payoutId}",
        configuration.base_path,
        pullPaymentId = crate::apis::urlencode(params.pull_payment_id),
        payoutId = crate::apis::urlencode(params.payout_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PayoutData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PayoutData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PullPaymentsGetPayoutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get payouts
pub async fn pull_payments_get_payouts(
    configuration: &configuration::Configuration,
    params: PullPaymentsGetPayoutsParams,
) -> Result<Vec<models::PayoutData>, Error<PullPaymentsGetPayoutsError>> {
    let uri_str = format!(
        "{}/api/v1/pull-payments/{pullPaymentId}/payouts",
        configuration.base_path,
        pullPaymentId = crate::apis::urlencode(params.pull_payment_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.include_cancelled {
        req_builder = req_builder.query(&[("includeCancelled", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PayoutData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PayoutData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PullPaymentsGetPayoutsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a pull payment
pub async fn pull_payments_get_pull_payment(
    configuration: &configuration::Configuration,
    params: PullPaymentsGetPullPaymentParams,
) -> Result<models::PullPaymentData, Error<PullPaymentsGetPullPaymentError>> {
    let uri_str = format!(
        "{}/api/v1/pull-payments/{pullPaymentId}",
        configuration.base_path,
        pullPaymentId = crate::apis::urlencode(params.pull_payment_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PullPaymentData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PullPaymentData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PullPaymentsGetPullPaymentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get Pull Payment LNURL details
pub async fn pull_payments_get_pull_payment_lnurl(
    configuration: &configuration::Configuration,
    params: PullPaymentsGetPullPaymentLnurlParams,
) -> Result<models::LnurlData, Error<PullPaymentsGetPullPaymentLnurlError>> {
    let uri_str = format!(
        "{}/api/v1/pull-payments/{pullPaymentId}/lnurl",
        configuration.base_path,
        pullPaymentId = crate::apis::urlencode(params.pull_payment_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LnurlData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LnurlData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PullPaymentsGetPullPaymentLnurlError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Linking a boltcard to a pull payment will allow you to pay via NFC with it, the money will be sent from the pull payment. The boltcard keys are generated using [Deterministic Boltcard Key Generation](https://github.com/boltcard/boltcard/blob/main/docs/DETERMINISTIC.md).
pub async fn pull_payments_link_boltcard(
    configuration: &configuration::Configuration,
    params: PullPaymentsLinkBoltcardParams,
) -> Result<models::PullPaymentsLinkBoltcard200Response, Error<PullPaymentsLinkBoltcardError>> {
    let uri_str = format!(
        "{}/api/v1/pull-payments/{pullPaymentId}/boltcards",
        configuration.base_path,
        pullPaymentId = crate::apis::urlencode(params.pull_payment_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.pull_payments_link_boltcard_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PullPaymentsLinkBoltcard200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PullPaymentsLinkBoltcard200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PullPaymentsLinkBoltcardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
