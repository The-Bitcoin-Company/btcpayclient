/*
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`store_on_chain_payment_methods_generate_on_chain_wallet`]
#[derive(Clone, Debug)]
pub struct StoreOnChainPaymentMethodsGenerateOnChainWalletParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    pub generate_on_chain_wallet_request: models::GenerateOnChainWalletRequest,
}

/// struct for passing parameters to the method [`store_on_chain_payment_methods_get_on_chain_payment_method_preview`]
#[derive(Clone, Debug)]
pub struct StoreOnChainPaymentMethodsGetOnChainPaymentMethodPreviewParams {
    /// The store ID
    pub store_id: String,
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// From which index to fetch the addresses
    pub offset: Option<f64>,
    /// Number of addresses to preview
    pub count: Option<f64>,
}

/// struct for passing parameters to the method [`store_on_chain_payment_methods_poston_chain_payment_method_preview`]
#[derive(Clone, Debug)]
pub struct StoreOnChainPaymentMethodsPostonChainPaymentMethodPreviewParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    pub store_on_chain_payment_methods_poston_chain_payment_method_preview_request:
        models::StoreOnChainPaymentMethodsPostonChainPaymentMethodPreviewRequest,
    /// From which index to fetch the addresses
    pub offset: Option<f64>,
    /// Number of addresses to preview
    pub count: Option<f64>,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_add_or_update_on_chain_wallet_link`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsAddOrUpdateOnChainWalletLinkParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// The object id to fetch
    pub object_id: String,
    /// The object type to fetch
    pub object_type: String,
    pub add_on_chain_wallet_object_link_request: models::AddOnChainWalletObjectLinkRequest,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_add_or_update_on_chain_wallet_objects`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsAddOrUpdateOnChainWalletObjectsParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    pub on_chain_wallet_object_data: models::OnChainWalletObjectData,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_create_on_chain_transaction`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsCreateOnChainTransactionParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    pub create_on_chain_transaction_request: models::CreateOnChainTransactionRequest,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_get_on_chain_fee_rate`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsGetOnChainFeeRateParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// The number of blocks away you are willing to target for confirmation. Defaults to the wallet's configured `RecommendedFeeBlockTarget`
    pub block_target: Option<f64>,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_get_on_chain_wallet_object`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsGetOnChainWalletObjectParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// The object id to fetch
    pub object_id: String,
    /// The object type to fetch
    pub object_type: String,
    /// Whether or not you should include neighbour's node data in the result (ie, `links.objectData`)
    pub include_neighbour_data: Option<bool>,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_get_on_chain_wallet_objects`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsGetOnChainWalletObjectsParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// The ids of objects to fetch, if used, type should be specified
    pub ids: Option<Vec<String>>,
    /// The type of object to fetch
    pub r#type: Option<String>,
    /// Whether or not you should include neighbour's node data in the result (ie, `links.objectData`)
    pub include_neighbour_data: Option<bool>,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_get_on_chain_wallet_receive_address`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsGetOnChainWalletReceiveAddressParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// Whether to generate a new address for this request even if the previous one was not used
    pub force_generate: Option<bool>,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_get_on_chain_wallet_transaction`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsGetOnChainWalletTransactionParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// The transaction id to fetch
    pub transaction_id: String,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_get_on_chain_wallet_utxos`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsGetOnChainWalletUtxosParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_patch_on_chain_wallet_transaction`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsPatchOnChainWalletTransactionParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// The transaction id to fetch
    pub transaction_id: String,
    pub patch_on_chain_transaction_request: models::PatchOnChainTransactionRequest,
    /// Whether to update the label/comments even if the transaction does not yet exist
    pub force: Option<String>,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_remove_on_chain_wallet_link`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsRemoveOnChainWalletLinkParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// The object id of the linked neighbour
    pub link_id: String,
    /// The object id to fetch
    pub object_id: String,
    /// The object type of the linked neighbour
    pub link_type: String,
    /// The object type to fetch
    pub object_type: String,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_remove_on_chain_wallet_object`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsRemoveOnChainWalletObjectParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// The object id to fetch
    pub object_id: String,
    /// The object type to fetch
    pub object_type: String,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_show_on_chain_wallet_histogram`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsShowOnChainWalletHistogramParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_show_on_chain_wallet_overview`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsShowOnChainWalletOverviewParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_show_on_chain_wallet_transactions`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsShowOnChainWalletTransactionsParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
    /// Transaction label to filter by
    pub label_filter: Option<String>,
    /// Maximum number of transactions to return
    pub limit: Option<i32>,
    /// Number of transactions to skip from the start
    pub skip: Option<i32>,
    /// Statuses to filter the transactions with
    pub status_filter: Option<Vec<models::TransactionStatus>>,
}

/// struct for passing parameters to the method [`store_on_chain_wallets_un_reserve_on_chain_wallet_receive_address`]
#[derive(Clone, Debug)]
pub struct StoreOnChainWalletsUnReserveOnChainWalletReceiveAddressParams {
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
}

/// struct for typed errors of method [`store_on_chain_payment_methods_generate_on_chain_wallet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainPaymentMethodsGenerateOnChainWalletError {
    Status400(Vec<models::ValidationProblemDetailsInner>),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_payment_methods_get_on_chain_payment_method_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainPaymentMethodsGetOnChainPaymentMethodPreviewError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_payment_methods_poston_chain_payment_method_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainPaymentMethodsPostonChainPaymentMethodPreviewError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_add_or_update_on_chain_wallet_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsAddOrUpdateOnChainWalletLinkError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_add_or_update_on_chain_wallet_objects`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsAddOrUpdateOnChainWalletObjectsError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_create_on_chain_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsCreateOnChainTransactionError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_get_on_chain_fee_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsGetOnChainFeeRateError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_get_on_chain_wallet_object`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsGetOnChainWalletObjectError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_get_on_chain_wallet_objects`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsGetOnChainWalletObjectsError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_get_on_chain_wallet_receive_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsGetOnChainWalletReceiveAddressError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_get_on_chain_wallet_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsGetOnChainWalletTransactionError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_get_on_chain_wallet_utxos`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsGetOnChainWalletUtxosError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_patch_on_chain_wallet_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsPatchOnChainWalletTransactionError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_remove_on_chain_wallet_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsRemoveOnChainWalletLinkError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_remove_on_chain_wallet_object`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsRemoveOnChainWalletObjectError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_show_on_chain_wallet_histogram`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsShowOnChainWalletHistogramError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_show_on_chain_wallet_overview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsShowOnChainWalletOverviewError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_show_on_chain_wallet_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsShowOnChainWalletTransactionsError {
    Status403(),
    Status404(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_on_chain_wallets_un_reserve_on_chain_wallet_receive_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOnChainWalletsUnReserveOnChainWalletReceiveAddressError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Generate a wallet and update the specified store's payment method to it
pub async fn store_on_chain_payment_methods_generate_on_chain_wallet(
    configuration: &configuration::Configuration,
    params: StoreOnChainPaymentMethodsGenerateOnChainWalletParams,
) -> Result<
    models::StoreOnChainPaymentMethodsGenerateOnChainWallet200Response,
    Error<StoreOnChainPaymentMethodsGenerateOnChainWalletError>,
> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/generate",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.generate_on_chain_wallet_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoreOnChainPaymentMethodsGenerateOnChainWallet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoreOnChainPaymentMethodsGenerateOnChainWallet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainPaymentMethodsGenerateOnChainWalletError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View addresses of the current payment method of the store
pub async fn store_on_chain_payment_methods_get_on_chain_payment_method_preview(
    configuration: &configuration::Configuration,
    params: StoreOnChainPaymentMethodsGetOnChainPaymentMethodPreviewParams,
) -> Result<
    models::OnChainPaymentMethodPreviewResultData,
    Error<StoreOnChainPaymentMethodsGetOnChainPaymentMethodPreviewError>,
> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/preview",
        configuration.base_path,
        storeId = crate::apis::urlencode(params.store_id),
        paymentMethodId = crate::apis::urlencode(params.payment_method_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnChainPaymentMethodPreviewResultData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnChainPaymentMethodPreviewResultData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainPaymentMethodsGetOnChainPaymentMethodPreviewError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View addresses of a proposed payment method of the store
pub async fn store_on_chain_payment_methods_poston_chain_payment_method_preview(
    configuration: &configuration::Configuration,
    params: StoreOnChainPaymentMethodsPostonChainPaymentMethodPreviewParams,
) -> Result<
    models::OnChainPaymentMethodPreviewResultData,
    Error<StoreOnChainPaymentMethodsPostonChainPaymentMethodPreviewError>,
> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/preview",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder
        .json(&params.store_on_chain_payment_methods_poston_chain_payment_method_preview_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnChainPaymentMethodPreviewResultData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnChainPaymentMethodPreviewResultData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainPaymentMethodsPostonChainPaymentMethodPreviewError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Add/Update wallet object link
pub async fn store_on_chain_wallets_add_or_update_on_chain_wallet_link(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsAddOrUpdateOnChainWalletLinkParams,
) -> Result<(), Error<StoreOnChainWalletsAddOrUpdateOnChainWalletLinkError>> {
    let uri_str = format!("{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}/links", configuration.base_path, paymentMethodId=crate::apis::urlencode(params.payment_method_id), storeId=crate::apis::urlencode(params.store_id), objectId=crate::apis::urlencode(params.object_id), objectType=crate::apis::urlencode(params.object_type));
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.add_on_chain_wallet_object_link_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsAddOrUpdateOnChainWalletLinkError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Add/Update wallet objects
pub async fn store_on_chain_wallets_add_or_update_on_chain_wallet_objects(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsAddOrUpdateOnChainWalletObjectsParams,
) -> Result<
    models::OnChainWalletObjectData,
    Error<StoreOnChainWalletsAddOrUpdateOnChainWalletObjectsError>,
> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.on_chain_wallet_object_data);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnChainWalletObjectData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnChainWalletObjectData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsAddOrUpdateOnChainWalletObjectsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create store on-chain wallet transaction
pub async fn store_on_chain_wallets_create_on_chain_transaction(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsCreateOnChainTransactionParams,
) -> Result<
    models::StoreOnChainWalletsCreateOnChainTransaction200Response,
    Error<StoreOnChainWalletsCreateOnChainTransactionError>,
> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.create_on_chain_transaction_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoreOnChainWalletsCreateOnChainTransaction200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoreOnChainWalletsCreateOnChainTransaction200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsCreateOnChainTransactionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get wallet onchain fee rate
pub async fn store_on_chain_wallets_get_on_chain_fee_rate(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsGetOnChainFeeRateParams,
) -> Result<models::OnChainWalletFeeRateData, Error<StoreOnChainWalletsGetOnChainFeeRateError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/feerate",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.block_target {
        req_builder = req_builder.query(&[("blockTarget", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnChainWalletFeeRateData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnChainWalletFeeRateData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsGetOnChainFeeRateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View wallet object
pub async fn store_on_chain_wallets_get_on_chain_wallet_object(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsGetOnChainWalletObjectParams,
) -> Result<models::OnChainWalletObjectData, Error<StoreOnChainWalletsGetOnChainWalletObjectError>>
{
    let uri_str = format!("{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}", configuration.base_path, paymentMethodId=crate::apis::urlencode(params.payment_method_id), storeId=crate::apis::urlencode(params.store_id), objectId=crate::apis::urlencode(params.object_id), objectType=crate::apis::urlencode(params.object_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.include_neighbour_data {
        req_builder = req_builder.query(&[("includeNeighbourData", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnChainWalletObjectData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnChainWalletObjectData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsGetOnChainWalletObjectError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View wallet objects
pub async fn store_on_chain_wallets_get_on_chain_wallet_objects(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsGetOnChainWalletObjectsParams,
) -> Result<
    Vec<models::OnChainWalletObjectData>,
    Error<StoreOnChainWalletsGetOnChainWalletObjectsError>,
> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("ids".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ids",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.r#type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_neighbour_data {
        req_builder = req_builder.query(&[("includeNeighbourData", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OnChainWalletObjectData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OnChainWalletObjectData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsGetOnChainWalletObjectsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get or generate address for wallet
pub async fn store_on_chain_wallets_get_on_chain_wallet_receive_address(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsGetOnChainWalletReceiveAddressParams,
) -> Result<
    models::OnChainWalletAddressData,
    Error<StoreOnChainWalletsGetOnChainWalletReceiveAddressError>,
> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/address",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.force_generate {
        req_builder = req_builder.query(&[("forceGenerate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnChainWalletAddressData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnChainWalletAddressData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsGetOnChainWalletReceiveAddressError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get store on-chain wallet transaction
pub async fn store_on_chain_wallets_get_on_chain_wallet_transaction(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsGetOnChainWalletTransactionParams,
) -> Result<
    models::OnChainWalletTransactionData,
    Error<StoreOnChainWalletsGetOnChainWalletTransactionError>,
> {
    let uri_str = format!("{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions/{transactionId}", configuration.base_path, paymentMethodId=crate::apis::urlencode(params.payment_method_id), storeId=crate::apis::urlencode(params.store_id), transactionId=crate::apis::urlencode(params.transaction_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnChainWalletTransactionData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnChainWalletTransactionData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsGetOnChainWalletTransactionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get store on-chain wallet utxos
pub async fn store_on_chain_wallets_get_on_chain_wallet_utxos(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsGetOnChainWalletUtxosParams,
) -> Result<Vec<models::OnChainWalletUtxoData>, Error<StoreOnChainWalletsGetOnChainWalletUtxosError>>
{
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/utxos",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OnChainWalletUtxoData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OnChainWalletUtxoData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsGetOnChainWalletUtxosError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Patch store on-chain wallet transaction info
pub async fn store_on_chain_wallets_patch_on_chain_wallet_transaction(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsPatchOnChainWalletTransactionParams,
) -> Result<
    models::OnChainWalletTransactionData,
    Error<StoreOnChainWalletsPatchOnChainWalletTransactionError>,
> {
    let uri_str = format!("{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions/{transactionId}", configuration.base_path, paymentMethodId=crate::apis::urlencode(params.payment_method_id), storeId=crate::apis::urlencode(params.store_id), transactionId=crate::apis::urlencode(params.transaction_id));
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = params.force {
        req_builder = req_builder.query(&[("force", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.patch_on_chain_transaction_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnChainWalletTransactionData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnChainWalletTransactionData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsPatchOnChainWalletTransactionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove wallet object link
pub async fn store_on_chain_wallets_remove_on_chain_wallet_link(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsRemoveOnChainWalletLinkParams,
) -> Result<(), Error<StoreOnChainWalletsRemoveOnChainWalletLinkError>> {
    let uri_str = format!("{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}/links/{linkType}/{linkId}", configuration.base_path, paymentMethodId=crate::apis::urlencode(params.payment_method_id), storeId=crate::apis::urlencode(params.store_id), linkId=crate::apis::urlencode(params.link_id), objectId=crate::apis::urlencode(params.object_id), linkType=crate::apis::urlencode(params.link_type), objectType=crate::apis::urlencode(params.object_type));
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsRemoveOnChainWalletLinkError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove wallet object
pub async fn store_on_chain_wallets_remove_on_chain_wallet_object(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsRemoveOnChainWalletObjectParams,
) -> Result<(), Error<StoreOnChainWalletsRemoveOnChainWalletObjectError>> {
    let uri_str = format!("{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}", configuration.base_path, paymentMethodId=crate::apis::urlencode(params.payment_method_id), storeId=crate::apis::urlencode(params.store_id), objectId=crate::apis::urlencode(params.object_id), objectType=crate::apis::urlencode(params.object_type));
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsRemoveOnChainWalletObjectError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View the balance histogram of the specified wallet
pub async fn store_on_chain_wallets_show_on_chain_wallet_histogram(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsShowOnChainWalletHistogramParams,
) -> Result<models::HistogramData, Error<StoreOnChainWalletsShowOnChainWalletHistogramError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/histogram",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::HistogramData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::HistogramData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsShowOnChainWalletHistogramError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the specified wallet
pub async fn store_on_chain_wallets_show_on_chain_wallet_overview(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsShowOnChainWalletOverviewParams,
) -> Result<
    models::OnChainWalletOverviewData,
    Error<StoreOnChainWalletsShowOnChainWalletOverviewError>,
> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnChainWalletOverviewData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnChainWalletOverviewData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsShowOnChainWalletOverviewError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get store on-chain wallet transactions
pub async fn store_on_chain_wallets_show_on_chain_wallet_transactions(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsShowOnChainWalletTransactionsParams,
) -> Result<
    Vec<models::OnChainWalletTransactionData>,
    Error<StoreOnChainWalletsShowOnChainWalletTransactionsError>,
> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.label_filter {
        req_builder = req_builder.query(&[("labelFilter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.status_filter {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("statusFilter".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "statusFilter",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OnChainWalletTransactionData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OnChainWalletTransactionData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsShowOnChainWalletTransactionsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UnReserve address
pub async fn store_on_chain_wallets_un_reserve_on_chain_wallet_receive_address(
    configuration: &configuration::Configuration,
    params: StoreOnChainWalletsUnReserveOnChainWalletReceiveAddressParams,
) -> Result<(), Error<StoreOnChainWalletsUnReserveOnChainWalletReceiveAddressError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/address",
        configuration.base_path,
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOnChainWalletsUnReserveOnChainWalletReceiveAddressError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
