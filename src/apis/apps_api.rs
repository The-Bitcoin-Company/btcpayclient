/*
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`app_delete_app_item_image`]
#[derive(Clone, Debug)]
pub struct AppDeleteAppItemImageParams {
    /// App ID
    pub app_id: String,
    /// The file ID
    pub file_id: String,
}

/// struct for passing parameters to the method [`apps_create_crowdfund_app`]
#[derive(Clone, Debug)]
pub struct AppsCreateCrowdfundAppParams {
    /// The store ID
    pub store_id: String,
    pub crowdfund_app_request: models::CrowdfundAppRequest,
}

/// struct for passing parameters to the method [`apps_create_point_of_sale_app`]
#[derive(Clone, Debug)]
pub struct AppsCreatePointOfSaleAppParams {
    /// The store ID
    pub store_id: String,
    pub point_of_sale_app_request: models::PointOfSaleAppRequest,
}

/// struct for passing parameters to the method [`apps_delete_app`]
#[derive(Clone, Debug)]
pub struct AppsDeleteAppParams {
    /// App ID
    pub app_id: String,
}

/// struct for passing parameters to the method [`apps_get_all_apps_for_store`]
#[derive(Clone, Debug)]
pub struct AppsGetAllAppsForStoreParams {
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`apps_get_app`]
#[derive(Clone, Debug)]
pub struct AppsGetAppParams {
    /// App ID
    pub app_id: String,
}

/// struct for passing parameters to the method [`apps_get_app_sales`]
#[derive(Clone, Debug)]
pub struct AppsGetAppSalesParams {
    /// App ID
    pub app_id: String,
    /// How many of the last days
    pub number_of_days: Option<f64>,
}

/// struct for passing parameters to the method [`apps_get_app_top_items`]
#[derive(Clone, Debug)]
pub struct AppsGetAppTopItemsParams {
    /// App ID
    pub app_id: String,
    /// How many of the items
    pub count: Option<f64>,
    /// Offset for paging
    pub offset: Option<f64>,
}

/// struct for passing parameters to the method [`apps_get_crowdfund_app`]
#[derive(Clone, Debug)]
pub struct AppsGetCrowdfundAppParams {
    /// App ID
    pub app_id: String,
}

/// struct for passing parameters to the method [`apps_get_point_of_sale_app`]
#[derive(Clone, Debug)]
pub struct AppsGetPointOfSaleAppParams {
    /// App ID
    pub app_id: String,
}

/// struct for passing parameters to the method [`apps_put_point_of_sale_app`]
#[derive(Clone, Debug)]
pub struct AppsPutPointOfSaleAppParams {
    /// App ID
    pub app_id: String,
    pub point_of_sale_app_request: models::PointOfSaleAppRequest,
}

/// struct for passing parameters to the method [`apps_upload_app_item_image`]
#[derive(Clone, Debug)]
pub struct AppsUploadAppItemImageParams {
    /// App ID
    pub app_id: String,
    /// The image
    pub file: Option<std::path::PathBuf>,
}

/// struct for typed errors of method [`app_delete_app_item_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppDeleteAppItemImageError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_create_crowdfund_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsCreateCrowdfundAppError {
    Status422(Vec<models::ValidationProblemDetailsInner>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_create_point_of_sale_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsCreatePointOfSaleAppError {
    Status422(Vec<models::ValidationProblemDetailsInner>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_delete_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsDeleteAppError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_get_all_apps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsGetAllAppsError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_get_all_apps_for_store`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsGetAllAppsForStoreError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_get_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsGetAppError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_get_app_sales`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsGetAppSalesError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_get_app_top_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsGetAppTopItemsError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_get_crowdfund_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsGetCrowdfundAppError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_get_point_of_sale_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsGetPointOfSaleAppError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_put_point_of_sale_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsPutPointOfSaleAppError {
    Status422(Vec<models::ValidationProblemDetailsInner>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`apps_upload_app_item_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppsUploadAppItemImageError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Deletes the app item image
pub async fn app_delete_app_item_image(
    configuration: &configuration::Configuration,
    params: AppDeleteAppItemImageParams,
) -> Result<(), Error<AppDeleteAppItemImageError>> {
    let uri_str = format!(
        "{}/api/v1/apps/{appId}/image/{fileId}",
        configuration.base_path,
        appId = crate::apis::urlencode(params.app_id),
        fileId = crate::apis::urlencode(params.file_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AppDeleteAppItemImageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn apps_create_crowdfund_app(
    configuration: &configuration::Configuration,
    params: AppsCreateCrowdfundAppParams,
) -> Result<models::CrowdfundAppData, Error<AppsCreateCrowdfundAppError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/apps/crowdfund",
        configuration.base_path,
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.crowdfund_app_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CrowdfundAppData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CrowdfundAppData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsCreateCrowdfundAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Point of Sale app allows accepting payments for items in a virtual store
pub async fn apps_create_point_of_sale_app(
    configuration: &configuration::Configuration,
    params: AppsCreatePointOfSaleAppParams,
) -> Result<models::PointOfSaleAppData, Error<AppsCreatePointOfSaleAppError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/apps/pos",
        configuration.base_path,
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.point_of_sale_app_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PointOfSaleAppData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PointOfSaleAppData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsCreatePointOfSaleAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes apps with specified ID
pub async fn apps_delete_app(
    configuration: &configuration::Configuration,
    params: AppsDeleteAppParams,
) -> Result<(), Error<AppsDeleteAppError>> {
    let uri_str = format!(
        "{}/api/v1/apps/{appId}",
        configuration.base_path,
        appId = crate::apis::urlencode(params.app_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsDeleteAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns basic app data for all apps for all stores
pub async fn apps_get_all_apps(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::AppBaseData>, Error<AppsGetAllAppsError>> {
    let uri_str = format!("{}/api/v1/apps", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AppBaseData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AppBaseData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsGetAllAppsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns basic app data for all apps for a store
pub async fn apps_get_all_apps_for_store(
    configuration: &configuration::Configuration,
    params: AppsGetAllAppsForStoreParams,
) -> Result<Vec<models::AppBaseData>, Error<AppsGetAllAppsForStoreError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/apps",
        configuration.base_path,
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AppBaseData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AppBaseData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsGetAllAppsForStoreError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns basic app data shared between all types of apps
pub async fn apps_get_app(
    configuration: &configuration::Configuration,
    params: AppsGetAppParams,
) -> Result<models::AppBaseData, Error<AppsGetAppError>> {
    let uri_str = format!(
        "{}/api/v1/apps/{appId}",
        configuration.base_path,
        appId = crate::apis::urlencode(params.app_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AppBaseData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AppBaseData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsGetAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns sales statistics for the app
pub async fn apps_get_app_sales(
    configuration: &configuration::Configuration,
    params: AppsGetAppSalesParams,
) -> Result<models::AppSalesStats, Error<AppsGetAppSalesError>> {
    let uri_str = format!(
        "{}/api/v1/apps/{appId}/sales",
        configuration.base_path,
        appId = crate::apis::urlencode(params.app_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.number_of_days {
        req_builder = req_builder.query(&[("numberOfDays", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AppSalesStats`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AppSalesStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsGetAppSalesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns top items statistics for the app
pub async fn apps_get_app_top_items(
    configuration: &configuration::Configuration,
    params: AppsGetAppTopItemsParams,
) -> Result<Vec<models::AppItemStats>, Error<AppsGetAppTopItemsError>> {
    let uri_str = format!(
        "{}/api/v1/apps/{appId}/top-items",
        configuration.base_path,
        appId = crate::apis::urlencode(params.app_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AppItemStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AppItemStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsGetAppTopItemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns crowdfund app data
pub async fn apps_get_crowdfund_app(
    configuration: &configuration::Configuration,
    params: AppsGetCrowdfundAppParams,
) -> Result<models::CrowdfundAppData, Error<AppsGetCrowdfundAppError>> {
    let uri_str = format!(
        "{}/api/v1/apps/crowdfund/{appId}",
        configuration.base_path,
        appId = crate::apis::urlencode(params.app_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CrowdfundAppData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CrowdfundAppData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsGetCrowdfundAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns POS app data
pub async fn apps_get_point_of_sale_app(
    configuration: &configuration::Configuration,
    params: AppsGetPointOfSaleAppParams,
) -> Result<models::PointOfSaleAppData, Error<AppsGetPointOfSaleAppError>> {
    let uri_str = format!(
        "{}/api/v1/apps/pos/{appId}",
        configuration.base_path,
        appId = crate::apis::urlencode(params.app_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PointOfSaleAppData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PointOfSaleAppData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsGetPointOfSaleAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Use this endpoint for updating the properties of a POS app
pub async fn apps_put_point_of_sale_app(
    configuration: &configuration::Configuration,
    params: AppsPutPointOfSaleAppParams,
) -> Result<models::PointOfSaleAppData, Error<AppsPutPointOfSaleAppError>> {
    let uri_str = format!(
        "{}/api/v1/apps/pos/{appId}",
        configuration.base_path,
        appId = crate::apis::urlencode(params.app_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.point_of_sale_app_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PointOfSaleAppData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PointOfSaleAppData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsPutPointOfSaleAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Uploads an image for a app item
pub async fn apps_upload_app_item_image(
    configuration: &configuration::Configuration,
    params: AppsUploadAppItemImageParams,
) -> Result<models::FileData, Error<AppsUploadAppItemImageError>> {
    let uri_str = format!(
        "{}/api/v1/apps/{appId}/image",
        configuration.base_path,
        appId = crate::apis::urlencode(params.app_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    let multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppsUploadAppItemImageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
