/*
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`invoices_activate_payment_method`]
#[derive(Clone, Debug)]
pub struct InvoicesActivatePaymentMethodParams {
    /// The invoice ID
    pub invoice_id: String,
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`invoices_archive_invoice`]
#[derive(Clone, Debug)]
pub struct InvoicesArchiveInvoiceParams {
    /// The invoice ID
    pub invoice_id: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`invoices_create_invoice`]
#[derive(Clone, Debug)]
pub struct InvoicesCreateInvoiceParams {
    /// The store ID
    pub store_id: String,
    pub create_invoice_request: models::CreateInvoiceRequest,
}

/// struct for passing parameters to the method [`invoices_get_invoice`]
#[derive(Clone, Debug)]
pub struct InvoicesGetInvoiceParams {
    /// The invoice ID
    pub invoice_id: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`invoices_get_invoice_payment_methods`]
#[derive(Clone, Debug)]
pub struct InvoicesGetInvoicePaymentMethodsParams {
    /// The invoice ID
    pub invoice_id: String,
    /// The store ID
    pub store_id: String,
    /// If `true`, `additionalData` might include sensitive data (such as xpub). Requires the permission `btcpay.store.canmodifystoresettings`.
    pub include_sensitive: Option<bool>,
    /// If default or true, only returns payments which are accounted (in Bitcoin, this mean not returning RBF'd or double spent payments)
    pub only_accounted_payments: Option<bool>,
}

/// struct for passing parameters to the method [`invoices_get_invoice_refund_trigger_data`]
#[derive(Clone, Debug)]
pub struct InvoicesGetInvoiceRefundTriggerDataParams {
    /// The invoice ID
    pub invoice_id: String,
    /// The payment method id of the payment method to update
    pub payment_method_id: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`invoices_get_invoices`]
#[derive(Clone, Debug)]
pub struct InvoicesGetInvoicesParams {
    /// The store ID
    pub store_id: String,
    /// Array of OrderIds to fetch the invoices for
    pub order_id: Option<Vec<String>>,
    /// A term that can help locating specific invoices.
    pub text_search: Option<String>,
    /// Array of statuses of invoices to be fetched
    pub status: Option<models::InvoiceStatus>,
    /// End date of the period to retrieve invoices
    pub end_date: Option<f64>,
    /// Number of records returned in response
    pub take: Option<f64>,
    /// Number of records to skip
    pub skip: Option<f64>,
    /// Start date of the period to retrieve invoices
    pub start_date: Option<f64>,
}

/// struct for passing parameters to the method [`invoices_mark_invoice_status`]
#[derive(Clone, Debug)]
pub struct InvoicesMarkInvoiceStatusParams {
    /// The invoice ID
    pub invoice_id: String,
    /// The store ID
    pub store_id: String,
    pub mark_invoice_status_request: models::MarkInvoiceStatusRequest,
}

/// struct for passing parameters to the method [`invoices_refund`]
#[derive(Clone, Debug)]
pub struct InvoicesRefundParams {
    /// The invoice ID
    pub invoice_id: String,
    /// The store ID
    pub store_id: String,
    pub invoices_refund_request: models::InvoicesRefundRequest,
}

/// struct for passing parameters to the method [`invoices_unarchive_invoice`]
#[derive(Clone, Debug)]
pub struct InvoicesUnarchiveInvoiceParams {
    /// The invoice ID
    pub invoice_id: String,
    /// The store ID
    pub store_id: String,
}

/// struct for passing parameters to the method [`invoices_update_invoice`]
#[derive(Clone, Debug)]
pub struct InvoicesUpdateInvoiceParams {
    /// The invoice ID
    pub invoice_id: String,
    /// The store ID
    pub store_id: String,
    pub update_invoice_request: models::UpdateInvoiceRequest,
}

/// struct for typed errors of method [`invoices_activate_payment_method`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesActivatePaymentMethodError {
    Status400(Vec<models::ValidationProblemDetailsInner>),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_archive_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesArchiveInvoiceError {
    Status400(Vec<models::ValidationProblemDetailsInner>),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_create_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesCreateInvoiceError {
    Status400(Vec<models::ValidationProblemDetailsInner>),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_get_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesGetInvoiceError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_get_invoice_payment_methods`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesGetInvoicePaymentMethodsError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_get_invoice_refund_trigger_data`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesGetInvoiceRefundTriggerDataError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_get_invoices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesGetInvoicesError {
    Status401(models::ProblemDetails),
    DefaultResponse(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_mark_invoice_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesMarkInvoiceStatusError {
    Status400(Vec<models::ValidationProblemDetailsInner>),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_refund`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesRefundError {
    Status400(Vec<models::ValidationProblemDetailsInner>),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_unarchive_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesUnarchiveInvoiceError {
    Status400(Vec<models::ValidationProblemDetailsInner>),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invoices_update_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvoicesUpdateInvoiceError {
    Status400(Vec<models::ValidationProblemDetailsInner>),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Activate an invoice payment method (if lazy payments mode is enabled)
pub async fn invoices_activate_payment_method(
    configuration: &configuration::Configuration,
    params: InvoicesActivatePaymentMethodParams,
) -> Result<(), Error<InvoicesActivatePaymentMethodError>> {
    let uri_str = format!("{}/api/v1/stores/{storeId}/invoices/{invoiceId}/payment-methods/{paymentMethodId}/activate", configuration.base_path, invoiceId=crate::apis::urlencode(params.invoice_id), paymentMethodId=crate::apis::urlencode(params.payment_method_id), storeId=crate::apis::urlencode(params.store_id));
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesActivatePaymentMethodError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Archives the specified invoice.
pub async fn invoices_archive_invoice(
    configuration: &configuration::Configuration,
    params: InvoicesArchiveInvoiceParams,
) -> Result<(), Error<InvoicesArchiveInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices/{invoiceId}",
        configuration.base_path,
        invoiceId = crate::apis::urlencode(params.invoice_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesArchiveInvoiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a new invoice
pub async fn invoices_create_invoice(
    configuration: &configuration::Configuration,
    params: InvoicesCreateInvoiceParams,
) -> Result<models::InvoiceData, Error<InvoicesCreateInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices",
        configuration.base_path,
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.create_invoice_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InvoiceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InvoiceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesCreateInvoiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the specified invoice
pub async fn invoices_get_invoice(
    configuration: &configuration::Configuration,
    params: InvoicesGetInvoiceParams,
) -> Result<models::InvoiceData, Error<InvoicesGetInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices/{invoiceId}",
        configuration.base_path,
        invoiceId = crate::apis::urlencode(params.invoice_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InvoiceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InvoiceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesGetInvoiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the specified invoice's payment methods
pub async fn invoices_get_invoice_payment_methods(
    configuration: &configuration::Configuration,
    params: InvoicesGetInvoicePaymentMethodsParams,
) -> Result<Vec<models::InvoicePaymentMethodDataModel>, Error<InvoicesGetInvoicePaymentMethodsError>>
{
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices/{invoiceId}/payment-methods",
        configuration.base_path,
        invoiceId = crate::apis::urlencode(params.invoice_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.include_sensitive {
        req_builder = req_builder.query(&[("includeSensitive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.only_accounted_payments {
        req_builder = req_builder.query(&[("onlyAccountedPayments", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::InvoicePaymentMethodDataModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::InvoicePaymentMethodDataModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesGetInvoicePaymentMethodsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View calculated refund amounts (payment then/now, invoice, overpaid) for the specified invoice/payment-method. This can be used preceding the POST /refund call.
pub async fn invoices_get_invoice_refund_trigger_data(
    configuration: &configuration::Configuration,
    params: InvoicesGetInvoiceRefundTriggerDataParams,
) -> Result<models::InvoiceRefundTriggerData, Error<InvoicesGetInvoiceRefundTriggerDataError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices/{invoiceId}/refund/{paymentMethodId}",
        configuration.base_path,
        invoiceId = crate::apis::urlencode(params.invoice_id),
        paymentMethodId = crate::apis::urlencode(params.payment_method_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InvoiceRefundTriggerData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InvoiceRefundTriggerData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesGetInvoiceRefundTriggerDataError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// View information about the existing invoices
pub async fn invoices_get_invoices(
    configuration: &configuration::Configuration,
    params: InvoicesGetInvoicesParams,
) -> Result<Vec<models::InvoiceData>, Error<InvoicesGetInvoicesError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices",
        configuration.base_path,
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.order_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("orderId".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "orderId",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.text_search {
        req_builder = req_builder.query(&[("textSearch", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::InvoiceData&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::InvoiceData&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesGetInvoicesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mark an invoice as invalid or settled.
pub async fn invoices_mark_invoice_status(
    configuration: &configuration::Configuration,
    params: InvoicesMarkInvoiceStatusParams,
) -> Result<models::InvoiceData, Error<InvoicesMarkInvoiceStatusError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices/{invoiceId}/status",
        configuration.base_path,
        invoiceId = crate::apis::urlencode(params.invoice_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.mark_invoice_status_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InvoiceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InvoiceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesMarkInvoiceStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Refund invoice
pub async fn invoices_refund(
    configuration: &configuration::Configuration,
    params: InvoicesRefundParams,
) -> Result<models::PullPaymentData, Error<InvoicesRefundError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices/{invoiceId}/refund",
        configuration.base_path,
        invoiceId = crate::apis::urlencode(params.invoice_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.invoices_refund_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PullPaymentData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PullPaymentData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesRefundError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Unarchive an invoice
pub async fn invoices_unarchive_invoice(
    configuration: &configuration::Configuration,
    params: InvoicesUnarchiveInvoiceParams,
) -> Result<models::InvoiceData, Error<InvoicesUnarchiveInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices/{invoiceId}/unarchive",
        configuration.base_path,
        invoiceId = crate::apis::urlencode(params.invoice_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InvoiceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InvoiceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesUnarchiveInvoiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates the specified invoice.
pub async fn invoices_update_invoice(
    configuration: &configuration::Configuration,
    params: InvoicesUpdateInvoiceParams,
) -> Result<models::InvoiceData, Error<InvoicesUpdateInvoiceError>> {
    let uri_str = format!(
        "{}/api/v1/stores/{storeId}/invoices/{invoiceId}",
        configuration.base_path,
        invoiceId = crate::apis::urlencode(params.invoice_id),
        storeId = crate::apis::urlencode(params.store_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.update_invoice_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InvoiceData`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InvoiceData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvoicesUpdateInvoiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
